<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Лабиринт Башни Дюны</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #222;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1, h2 {
      text-align: center;
    }
    /* Экран выбора персонажей */
    .screen {
      width: 100%;
      max-width: 600px;
      text-align: center;
      margin-top: 20px;
    }
    #character-options button {
      margin: 10px;
      border: none;
      background: #444;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
    }
    #character-options button:hover {
      background: #555;
    }
    #character-options img {
      display: block;
      margin: 0 auto 5px;
      width: 50px;
      height: 50px;
    }
    /* Экран игры */
    #game-info {
      margin: 10px;
      font-size: 16px;
    }
    #maze-container {
      display: grid;
      border: 2px solid #eee;
      margin-bottom: 10px;
      position: relative;
    }
    .cell {
      width: 20px;
      height: 20px;
      box-sizing: border-box;
      position: relative;
    }
    /* Стены ячеек */
    .wall-top    { border-top: 2px solid #eee; }
    .wall-right  { border-right: 2px solid #eee; }
    .wall-bottom { border-bottom: 2px solid #eee; }
    .wall-left   { border-left: 2px solid #eee; }
    /* Туман войны */
    .fog {
      background: #000;
      border-color: #000;
    }
    /* Загадочная комната */
    .puzzle {
      background: #444;
    }
    .puzzle::after {
      content: "?";
      position: absolute;
      top: 0;
      right: 0;
      font-size: 14px;
      color: #ff6600;
    }
    /* Точка боя */
    .battle-marker {
      position: absolute;
      width: 8px;
      height: 8px;
      background: red;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
    }
    /* Финальная ячейка – дверь главного зала */
    .final {
      background: #0055aa;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }
    /* Кнопки управления */
    #controls button {
      padding: 5px 10px;
      margin: 2px;
      font-size: 16px;
      cursor: pointer;
    }
    /* Модальное окно */
    #modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    #modal-content {
      background: #333;
      padding: 20px;
      max-width: 400px;
      text-align: center;
      border-radius: 5px;
    }
    #modal input[type="text"] {
      padding: 5px;
      margin: 10px;
      width: 80%;
    }
  </style>
</head>
<body>
  <!-- Экран выбора персонажей -->
  <div id="character-selection" class="screen active">
    <h1>Выбор персонажа</h1>
    <div id="selection-info">Выбор персонажа для игрока 1</div>
    <div id="character-options">
      <button onclick="selectCharacter('Вахаиб', 6, 'https://i.imgur.com/nWpZOkZ.png')">
        <img src="https://i.imgur.com/nWpZOkZ.png" alt="Вахаиб">
        Вахаиб (6 клеток)
      </button>
      <button onclick="selectCharacter('Гнилион', 8, 'https://i.imgur.com/tZSfmRn.png')">
        <img src="https://i.imgur.com/tZSfmRn.png" alt="Гнилион">
        Гнилион (8 клеток)
      </button>
      <button onclick="selectCharacter('Залупатор', 5, 'https://i.imgur.com/CSNKO2Q.png')">
        <img src="https://i.imgur.com/CSNKO2Q.png" alt="Залупатор">
        Залупатор (5 клеток)
      </button>
      <button onclick="selectCharacter('Офилнекр', 5, 'https://i.imgur.com/oJCnoYW.png')">
        <img src="https://i.imgur.com/oJCnoYW.png" alt="Офилнекр">
        Офилнекр (5 клеток)
      </button>
    </div>
  </div>

  <!-- Экран игры -->
  <div id="game-screen" class="screen" style="display: none;">
    <div id="game-info">
      <span id="turnInfo"></span> | Ключей: <span id="keysCount">0</span>/3
    </div>
    <div id="maze-container"></div>
    <div id="controls">
      <button onclick="movePlayer('up')">↑</button><br>
      <button onclick="movePlayer('left')">←</button>
      <button onclick="movePlayer('right')">→</button><br>
      <button onclick="movePlayer('down')">↓</button>
    </div>
  </div>

  <!-- Модальное окно -->
  <div id="modal">
    <div id="modal-content"></div>
  </div>

  <script>
    /* ==== Выбор персонажей и запуск игры ==== */
    const totalPlayers = 4;
    let players = [];
    let currentSelectionIndex = 0;
    let currentPlayerIndex = 0;
    const selectionInfoDiv = document.getElementById("selection-info");
    const characterSelectionDiv = document.getElementById("character-selection");
    const gameScreenDiv = document.getElementById("game-screen");
    const turnInfoSpan = document.getElementById("turnInfo");
    const keysCountEl = document.getElementById("keysCount");

    selectionInfoDiv.innerText = "Выбор персонажа для игрока 1";

    function selectCharacter(name, moveRange, icon) {
      // Создаем объект игрока; начальные координаты назначим позже
      players.push({ name: name, moveRange: moveRange, movesLeft: moveRange, keys: 0, icon: icon, x: 0, y: 0 });
      currentSelectionIndex++;
      if (currentSelectionIndex < totalPlayers) {
        selectionInfoDiv.innerText = "Выбор персонажа для игрока " + (currentSelectionIndex + 1);
      } else {
        startGame();
      }
    }

    function startGame() {
      // Скрываем экран выбора и показываем игровой
      characterSelectionDiv.style.display = "none";
      gameScreenDiv.style.display = "block";

      // Размеры лабиринта (будет 45x45)
      // Назначаем начальные позиции – по углам лабиринта
      players[0].x = 0; players[0].y = 0;
      players[1].x = 0; players[1].y = mazeHeight - 1;
      players[2].x = mazeWidth - 1; players[2].y = 0;
      players[3].x = mazeWidth - 1; players[3].y = mazeHeight - 1;

      updateTurnInfo();
      initMaze();
    }

    /* ==== Параметры лабиринта ==== */
    const mazeWidth = 45;
    const mazeHeight = 45;
    const cellSize = 20; // в пикселях
    const visibilityRange = 3; // видны клетки в радиусе 3

    // Загадки по вселенной Дюны
    const puzzlesList = [
      { question: "Какой ресурс считается важнейшей валютой Арракиса?", answer: "спайс" },
      { question: "Назовите гигантского песчаного червя, бродящего по пустыне.", answer: "червь" },
      { question: "Как называются народ, умеющий выживать в пустыне Арракиса?", answer: "фремены" },
      { question: "Что является символом власти на Арракисе?", answer: "спайс" },
      { question: "Назовите ресурс, за который борются все фракции Империи.", answer: "спайс" }
    ];

    let maze = [];

    /* ==== Генерация лабиринта ==== */
    function initMaze() {
      generateMaze();
      renderMaze();
    }

    function generateMaze() {
      // Инициализируем ячейки
      for (let y = 0; y < mazeHeight; y++) {
        maze[y] = [];
        for (let x = 0; x < mazeWidth; x++) {
          maze[y][x] = {
            x: x, y: y,
            walls: { top: true, right: true, bottom: true, left: true },
            visited: false,
            puzzle: false,
            solved: false,
            puzzleData: null,
            battle: false
          };
        }
      }
      // Алгоритм обхода с возвратом (backtracking)
      let stack = [];
      let current = maze[0][0];
      current.visited = true;
      while (true) {
        let neighbors = getUnvisitedNeighbors(current);
        if (neighbors.length > 0) {
          let next = neighbors[Math.floor(Math.random() * neighbors.length)];
          removeWalls(current, next);
          stack.push(current);
          next.visited = true;
          current = next;
        } else if (stack.length > 0) {
          current = stack.pop();
        } else {
          break;
        }
      }
      // Размечаем комнаты с загадками (20% шанс, исключая угловые и финальную ячейку)
      for (let y = 0; y < mazeHeight; y++) {
        for (let x = 0; x < mazeWidth; x++) {
          if (((x !== 0 || y !== 0) &&
               (x !== 0 || y !== mazeHeight - 1) &&
               (x !== mazeWidth - 1 || y !== 0) &&
               (x !== mazeWidth - 1 || y !== mazeHeight - 1)) &&
              !(x === mazeWidth - 1 && y === mazeHeight - 1)) {
            if (Math.random() < 0.2) {
              maze[y][x].puzzle = true;
              maze[y][x].puzzleData = puzzlesList[Math.floor(Math.random() * puzzlesList.length)];
            }
          }
        }
      }
      // Размещаем точки боя с вероятностью 10% (если в клетке нет загадки)
      for (let y = 0; y < mazeHeight; y++) {
        for (let x = 0; x < mazeWidth; x++) {
          if (!maze[y][x].puzzle && ((x !== 0 || y !== 0) && (x !== mazeWidth - 1 || y !== mazeHeight - 1))) {
            if (Math.random() < 0.1) {
              maze[y][x].battle = true;
            }
          }
        }
      }
    }

    function getUnvisitedNeighbors(cell) {
      let neighbors = [];
      let { x, y } = cell;
      if (y > 0 && !maze[y - 1][x].visited) neighbors.push(maze[y - 1][x]);
      if (x < mazeWidth - 1 && !maze[y][x + 1].visited) neighbors.push(maze[y][x + 1]);
      if (y < mazeHeight - 1 && !maze[y + 1][x].visited) neighbors.push(maze[y + 1][x]);
      if (x > 0 && !maze[y][x - 1].visited) neighbors.push(maze[y][x - 1]);
      return neighbors;
    }

    function removeWalls(current, next) {
      let xDiff = current.x - next.x;
      let yDiff = current.y - next.y;
      if (xDiff === 1) {
        current.walls.left = false;
        next.walls.right = false;
      } else if (xDiff === -1) {
        current.walls.right = false;
        next.walls.left = false;
      }
      if (yDiff === 1) {
        current.walls.top = false;
        next.walls.bottom = false;
      } else if (yDiff === -1) {
        current.walls.bottom = false;
        next.walls.top = false;
      }
    }

    /* ==== Отрисовка лабиринта ==== */
    const mazeContainer = document.getElementById("maze-container");

    function renderMaze() {
      mazeContainer.innerHTML = "";
      mazeContainer.style.gridTemplateColumns = `repeat(${mazeWidth}, ${cellSize}px)`;
      for (let y = 0; y < mazeHeight; y++) {
        for (let x = 0; x < mazeWidth; x++) {
          const cell = maze[y][x];
          const cellDiv = document.createElement("div");
          cellDiv.classList.add("cell");
          if (cell.walls.top) cellDiv.classList.add("wall-top");
          if (cell.walls.right) cellDiv.classList.add("wall-right");
          if (cell.walls.bottom) cellDiv.classList.add("wall-bottom");
          if (cell.walls.left) cellDiv.classList.add("wall-left");
          if (cell.puzzle && !cell.solved) cellDiv.classList.add("puzzle");
          // Финальная ячейка – дверь главного зала
          if (x === mazeWidth - 1 && y === mazeHeight - 1) {
            cellDiv.classList.add("final");
            cellDiv.innerText = "Дверь";
          }
          // Точка боя
          if (cell.battle) {
            const battleMarker = document.createElement("div");
            battleMarker.classList.add("battle-marker");
            cellDiv.appendChild(battleMarker);
          }
          // Отображаем иконки игроков, если они находятся в этой клетке
          players.forEach((p, index) => {
            if (p.x === x && p.y === y) {
              const img = document.createElement("img");
              img.src = p.icon;
              img.alt = p.name;
              img.style.width = "16px";
              img.style.height = "16px";
              img.style.position = "absolute";
              img.style.left = (2 + (index * 2)) + "px";
              img.style.top = (2 + (index * 2)) + "px";
              cellDiv.appendChild(img);
            }
          });
          // Туман войны: показываем только клетки, находящиеся в радиусе visibilityRange от активного игрока
          const currentPlayer = players[currentPlayerIndex];
          if (Math.max(Math.abs(x - currentPlayer.x), Math.abs(y - currentPlayer.y)) > visibilityRange) {
            cellDiv.classList.add("fog");
          }
          cellDiv.id = `cell-${x}-${y}`;
          mazeContainer.appendChild(cellDiv);
        }
      }
    }

    function updateMaze() {
      renderMaze();
      updateTurnInfo();
      checkCurrentCell();
    }

    /* ==== Управление ходом ==== */
    function updateTurnInfo() {
      const currentPlayer = players[currentPlayerIndex];
      turnInfoSpan.innerText = `Ход: ${currentPlayer.name} (Осталось ходов: ${currentPlayer.movesLeft})`;
      keysCountEl.innerText = currentPlayer.keys;
    }

    // Перемещение текущего игрока
    function movePlayer(direction) {
      const currentPlayer = players[currentPlayerIndex];
      let cx = currentPlayer.x, cy = currentPlayer.y;
      const cell = maze[cy][cx];
      let newX = cx, newY = cy;
      if (direction === "up" && !cell.walls.top) newY--;
      else if (direction === "down" && !cell.walls.bottom) newY++;
      else if (direction === "left" && !cell.walls.left) newX--;
      else if (direction === "right" && !cell.walls.right) newX++;
      if (newX < 0 || newX >= mazeWidth || newY < 0 || newY >= mazeHeight) return;
      currentPlayer.x = newX;
      currentPlayer.y = newY;
      currentPlayer.movesLeft--;
      updateMaze();
      // Если текущий игрок исчерпал ходы – переходим к следующему
      if (currentPlayer.movesLeft <= 0) {
        currentPlayer.movesLeft = currentPlayer.moveRange;
        currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
        updateMaze();
      }
    }

    // Проверка событий в клетке для текущего игрока
    function checkCurrentCell() {
      const currentPlayer = players[currentPlayerIndex];
      const cell = maze[currentPlayer.y][currentPlayer.x];
      if (cell.battle) {
        triggerBattle(cell);
        return;
      }
      if (cell.puzzle && !cell.solved) {
        triggerPuzzle(cell);
        return;
      }
      if (currentPlayer.x === mazeWidth - 1 && currentPlayer.y === mazeHeight - 1) {
        if (currentPlayer.keys >= 3) {
          triggerFinalDoor();
        } else {
          showModal(`<p>Дверь заблокирована. Соберите 3 ключа, чтобы войти в главный зал.</p>
                     <button onclick="closeModal()">Закрыть</button>`);
        }
      }
    }

    /* ==== Модальное окно ==== */
    const modal = document.getElementById("modal");
    const modalContent = document.getElementById("modal-content");

    function showModal(content) {
      modalContent.innerHTML = content;
      modal.style.display = "flex";
    }
    function closeModal() {
      modal.style.display = "none";
      updateMaze();
    }
    function restartGame() {
      location.reload();
    }

    /* ==== События: загадки, бой и финал ==== */
    function triggerPuzzle(cell) {
      const puzzle = cell.puzzleData;
      let html = `<h2>Загадка</h2>
                  <p>${puzzle.question}</p>
                  <input type="text" id="puzzleAnswer" placeholder="Ваш ответ">
                  <br>
                  <button onclick="checkPuzzle(${cell.x},${cell.y})">Ответить</button>
                  <button onclick="closeModal()">Отмена</button>`;
      showModal(html);
    }

    function checkPuzzle(x, y) {
      const answer = document.getElementById("puzzleAnswer").value.trim().toLowerCase();
      const correct = maze[y][x].puzzleData.answer.toLowerCase();
      const currentPlayer = players[currentPlayerIndex];
      if (answer === correct) {
        maze[y][x].solved = true;
        currentPlayer.keys++;
        showModal(`<p>Верно! Вы получили Ключ.</p>
                   <button onclick="closeModal()">Продолжить</button>`);
      } else {
        showModal(`<p>Неверный ответ. Попробуйте позже.</p>
                   <button onclick="closeModal()">Закрыть</button>`);
      }
      updateMaze();
    }

    function triggerBattle(cell) {
      cell.battle = false; // чтобы событие не повторялось
      showModal(`<h2>Бой!</h2>
                 <p>Вы столкнулись с противником. Начинается бой!</p>
                 <button onclick="closeModal()">Продолжить</button>`);
    }

    function triggerFinalDoor() {
      let html = `<h2>Главный зал</h2>
                  <p>Перед вами две двери. Одна ведёт к свободе, другая – к гибели.</p>
                  <p>Выберите дверь:</p>
                  <button onclick="chooseFinalDoor(0)">Дверь 1</button>
                  <button onclick="chooseFinalDoor(1)">Дверь 2</button>`;
      showModal(html);
    }

    let safeDoor = Math.random() < 0.5 ? 0 : 1;
    function chooseFinalDoor(choice) {
      if (choice === safeDoor) {
        showModal(`<h2>Победа!</h2>
                   <p>Вы выбрали правильную дверь и вышли на свободу!</p>
                   <button onclick="restartGame()">Начать заново</button>`);
      } else {
        showModal(`<h2>Поражение</h2>
                   <p>Неверный выбор! Эта дверь оказалась смертельной.</p>
                   <button onclick="restartGame()">Начать заново</button>`);
      }
    }
  </script>
</body>
</html>
